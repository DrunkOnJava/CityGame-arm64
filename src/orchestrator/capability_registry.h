// SimCity ARM64 DevActor Capability Registry
// Plugin-style worker capability registration and discovery system

#ifndef CAPABILITY_REGISTRY_H
#define CAPABILITY_REGISTRY_H

#include <stdint.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

// Maximum limits
#define MAX_CAPABILITY_NAME_LENGTH 64
#define MAX_CAPABILITY_VERSION_LENGTH 16
#define MAX_CAPABILITY_DESCRIPTION_LENGTH 256
#define MAX_CAPABILITY_UUID_LENGTH 37
#define MAX_CAPABILITY_DEPENDENCIES 8
#define MAX_WORKER_NAME_LENGTH 64
#define MAX_WORKER_VERSION_LENGTH 16
#define MAX_WORKER_DESCRIPTION_LENGTH 256
#define MAX_REQUIRED_CAPABILITIES 16

// Error codes
typedef enum {
    CAPABILITY_SUCCESS = 0,
    CAPABILITY_ERROR_INVALID_PARAMS = -1,
    CAPABILITY_ERROR_MEMORY = -2,
    CAPABILITY_ERROR_NOT_FOUND = -3,
    CAPABILITY_ERROR_DUPLICATE_NAME = -4,
    CAPABILITY_ERROR_INVALID_CAPABILITY = -5,
    CAPABILITY_ERROR_WORKER_NOT_FOUND = -6,
    CAPABILITY_ERROR_NO_SUITABLE_WORKER = -7,
    CAPABILITY_ERROR_PLUGIN_LOAD_FAILED = -8,
    CAPABILITY_ERROR_VERSION_MISMATCH = -9
} CapabilityResult;\n\n// Capability categories\ntypedef enum {\n    CAPABILITY_CATEGORY_CORE = 0,\n    CAPABILITY_CATEGORY_SIMULATION = 1,\n    CAPABILITY_CATEGORY_RENDERING = 2,\n    CAPABILITY_CATEGORY_AI = 3,\n    CAPABILITY_CATEGORY_NETWORKING = 4,\n    CAPABILITY_CATEGORY_PERSISTENCE = 5,\n    CAPABILITY_CATEGORY_UI = 6,\n    CAPABILITY_CATEGORY_AUDIO = 7,\n    CAPABILITY_CATEGORY_TESTING = 8,\n    CAPABILITY_CATEGORY_COORDINATION = 9,\n    CAPABILITY_CATEGORY_MONITORING = 10,\n    CAPABILITY_CATEGORY_COUNT\n} CapabilityCategory;\n\n// Capability priorities\ntypedef enum {\n    CAPABILITY_PRIORITY_LOW = 0,\n    CAPABILITY_PRIORITY_MEDIUM = 1,\n    CAPABILITY_PRIORITY_HIGH = 2,\n    CAPABILITY_PRIORITY_CRITICAL = 3,\n    CAPABILITY_PRIORITY_COUNT\n} CapabilityPriority;\n\n// Worker states\ntypedef enum {\n    WORKER_STATE_IDLE = 0,\n    WORKER_STATE_BUSY = 1,\n    WORKER_STATE_ERROR = 2,\n    WORKER_STATE_OFFLINE = 3\n} WorkerState;\n\n// Resource requirements\ntypedef struct {\n    float cpu_usage;              // CPU usage percentage (0.0 - 1.0)\n    uint32_t memory_mb;           // Memory requirement in MB\n    float network_bandwidth_mbps; // Network bandwidth in Mbps\n} ResourceRequirements;\n\n// Capability definition\ntypedef struct {\n    char name[MAX_CAPABILITY_NAME_LENGTH];\n    char version[MAX_CAPABILITY_VERSION_LENGTH];\n    char description[MAX_CAPABILITY_DESCRIPTION_LENGTH];\n    char uuid[MAX_CAPABILITY_UUID_LENGTH];\n    \n    CapabilityCategory category;\n    CapabilityPriority priority;\n    \n    ResourceRequirements resource_requirements;\n    \n    // Dependencies\n    uint32_t dependencies_count;\n    char dependencies[MAX_CAPABILITY_DEPENDENCIES][MAX_CAPABILITY_NAME_LENGTH];\n    \n    // Function pointers for capability execution\n    int (*init_func)(void);\n    int (*execute_func)(const void* input, void* output);\n    void (*cleanup_func)(void);\n    \n    // Plugin-specific data\n    void* plugin_data;\n} Capability;\n\n// Worker information\ntypedef struct {\n    uint32_t id;                              // Assigned by registry\n    char name[MAX_WORKER_NAME_LENGTH];\n    char version[MAX_WORKER_VERSION_LENGTH];\n    char description[MAX_WORKER_DESCRIPTION_LENGTH];\n    \n    uint32_t max_concurrent_tasks;\n    uint32_t heartbeat_interval_ms;\n    \n    // Resource limits\n    ResourceRequirements max_resources;\n} WorkerInfo;\n\n// Task requirements for worker matching\ntypedef struct {\n    char required_capabilities[MAX_REQUIRED_CAPABILITIES][MAX_CAPABILITY_NAME_LENGTH];\n    uint32_t required_capabilities_count;\n    \n    uint32_t min_cpu_cores;\n    uint32_t min_memory_mb;\n    float min_network_bandwidth_mbps;\n    \n    CapabilityPriority min_priority;\n    uint32_t timeout_ms;\n} TaskRequirements;\n\n// Registry statistics\ntypedef struct {\n    uint32_t total_workers;\n    uint32_t total_capabilities;\n    uint32_t idle_workers;\n    uint32_t busy_workers;\n    uint32_t error_workers;\n    bool hot_reload_enabled;\n    char plugin_directory[256];\n} RegistryStats;\n\n//==============================================================================\n// REGISTRY MANAGEMENT\n//==============================================================================\n\n/**\n * Initialize the capability registry\n * @param plugin_dir Directory to scan for plugins (NULL for default)\n * @return CAPABILITY_SUCCESS on success, error code on failure\n */\nint capability_registry_init(const char* plugin_dir);\n\n/**\n * Shutdown the capability registry and cleanup resources\n */\nvoid capability_registry_shutdown(void);\n\n//==============================================================================\n// WORKER REGISTRATION\n//==============================================================================\n\n/**\n * Register a new DevActor worker\n * @param worker_info Worker information\n * @param worker_id Output parameter for assigned worker ID\n * @return CAPABILITY_SUCCESS on success, error code on failure\n */\nint capability_registry_register_worker(const WorkerInfo* worker_info, uint32_t* worker_id);\n\n/**\n * Unregister a DevActor worker\n * @param worker_id Worker ID to unregister\n * @return CAPABILITY_SUCCESS on success, error code on failure\n */\nint capability_registry_unregister_worker(uint32_t worker_id);\n\n/**\n * Update worker state\n * @param worker_id Worker ID\n * @param state New worker state\n * @return CAPABILITY_SUCCESS on success, error code on failure\n */\nint capability_registry_update_worker_state(uint32_t worker_id, WorkerState state);\n\n/**\n * Send heartbeat for a worker\n * @param worker_id Worker ID\n * @return CAPABILITY_SUCCESS on success, error code on failure\n */\nint capability_registry_worker_heartbeat(uint32_t worker_id);\n\n//==============================================================================\n// CAPABILITY REGISTRATION\n//==============================================================================\n\n/**\n * Register a capability for a worker\n * @param worker_id Worker ID\n * @param capability Capability to register\n * @return CAPABILITY_SUCCESS on success, error code on failure\n */\nint capability_registry_register_capability(uint32_t worker_id, const Capability* capability);\n\n/**\n * Unregister a capability from a worker\n * @param worker_id Worker ID\n * @param capability_name Name of capability to unregister\n * @return CAPABILITY_SUCCESS on success, error code on failure\n */\nint capability_registry_unregister_capability(uint32_t worker_id, const char* capability_name);\n\n/**\n * Load built-in capabilities for core DevActors\n * @return CAPABILITY_SUCCESS on success, error code on failure\n */\nint capability_registry_load_builtin_capabilities(void);\n\n//==============================================================================\n// CAPABILITY DISCOVERY\n//==============================================================================\n\n/**\n * Find workers that have a specific capability\n * @param capability_name Name of capability to search for\n * @param worker_ids Array to store found worker IDs\n * @param max_workers Maximum number of workers to return\n * @param found_count Output parameter for number of workers found\n * @return CAPABILITY_SUCCESS on success, error code on failure\n */\nint capability_registry_find_workers_with_capability(const char* capability_name, \n                                                    uint32_t* worker_ids, \n                                                    uint32_t max_workers, \n                                                    uint32_t* found_count);\n\n/**\n * Get all capabilities for a specific worker\n * @param worker_id Worker ID\n * @param capabilities Array to store capabilities\n * @param max_capabilities Maximum number of capabilities to return\n * @param capability_count Output parameter for number of capabilities found\n * @return CAPABILITY_SUCCESS on success, error code on failure\n */\nint capability_registry_get_worker_capabilities(uint32_t worker_id, \n                                               Capability* capabilities, \n                                               uint32_t max_capabilities, \n                                               uint32_t* capability_count);\n\n/**\n * Find the best worker for a given task\n * @param requirements Task requirements\n * @param worker_id Output parameter for best worker ID\n * @param compatibility_score Output parameter for compatibility score (0.0-1.0)\n * @return CAPABILITY_SUCCESS on success, error code on failure\n */\nint capability_registry_find_best_worker_for_task(const TaskRequirements* requirements, \n                                                 uint32_t* worker_id, \n                                                 float* compatibility_score);\n\n/**\n * List all registered workers\n * @param worker_ids Array to store worker IDs\n * @param max_workers Maximum number of workers to return\n * @param worker_count Output parameter for number of workers found\n * @return CAPABILITY_SUCCESS on success, error code on failure\n */\nint capability_registry_list_workers(uint32_t* worker_ids, uint32_t max_workers, uint32_t* worker_count);\n\n//==============================================================================\n// PLUGIN MANAGEMENT\n//==============================================================================\n\n/**\n * Load capabilities from a plugin file\n * @param plugin_path Path to plugin (.so or .dylib file)\n * @return CAPABILITY_SUCCESS on success, error code on failure\n */\nint capability_registry_load_plugin(const char* plugin_path);\n\n/**\n * Unload a plugin and its capabilities\n * @param plugin_path Path to plugin file\n * @return CAPABILITY_SUCCESS on success, error code on failure\n */\nint capability_registry_unload_plugin(const char* plugin_path);\n\n/**\n * Reload a plugin (for hot-reloading)\n * @param plugin_path Path to plugin file\n * @return CAPABILITY_SUCCESS on success, error code on failure\n */\nint capability_registry_reload_plugin(const char* plugin_path);\n\n/**\n * Enable or disable hot-reloading of plugins\n * @param enabled True to enable, false to disable\n */\nvoid capability_registry_set_hot_reload(bool enabled);\n\n//==============================================================================\n// WORKER COMPATIBILITY SCORING\n//==============================================================================\n\n/**\n * Calculate compatibility score between worker and task requirements\n * @param worker Worker to evaluate\n * @param requirements Task requirements\n * @return Compatibility score (0.0 = incompatible, 1.0 = perfect match)\n */\nfloat calculate_worker_compatibility(const struct WorkerNode* worker, const TaskRequirements* requirements);\n\n//==============================================================================\n// STATISTICS AND DEBUGGING\n//==============================================================================\n\n/**\n * Get registry statistics\n * @param stats Output parameter for statistics\n * @return CAPABILITY_SUCCESS on success, error code on failure\n */\nint capability_registry_get_stats(RegistryStats* stats);\n\n/**\n * Print registry statistics to stdout\n */\nvoid capability_registry_print_stats(void);\n\n/**\n * Validate a capability definition\n * @param capability Capability to validate\n * @return CAPABILITY_SUCCESS if valid, error code otherwise\n */\nint capability_registry_validate_capability(const Capability* capability);\n\n//==============================================================================\n// CONVENIENCE MACROS FOR DEVACTOR INTEGRATION\n//==============================================================================\n\n// Macro to register a DevActor worker with capabilities\n#define REGISTER_DEVACTOR_WORKER(name, version, desc, caps, cap_count) do { \\\n    WorkerInfo worker = { \\\n        .name = name, \\\n        .version = version, \\\n        .description = desc, \\\n        .max_concurrent_tasks = 4, \\\n        .heartbeat_interval_ms = 1000 \\\n    }; \\\n    uint32_t worker_id; \\\n    if (capability_registry_register_worker(&worker, &worker_id) == CAPABILITY_SUCCESS) { \\\n        for (int i = 0; i < cap_count; i++) { \\\n            capability_registry_register_capability(worker_id, &caps[i]); \\\n        } \\\n    } \\\n} while(0)\n\n// Macro to find worker with specific capability\n#define FIND_WORKER_WITH_CAPABILITY(cap_name, worker_id) do { \\\n    uint32_t workers[1]; \\\n    uint32_t found; \\\n    if (capability_registry_find_workers_with_capability(cap_name, workers, 1, &found) == CAPABILITY_SUCCESS && found > 0) { \\\n        worker_id = workers[0]; \\\n    } else { \\\n        worker_id = 0; \\\n    } \\\n} while(0)\n\n// Macro to create capability with common defaults\n#define CREATE_CAPABILITY(name, ver, desc, cat, pri) { \\\n    .name = name, \\\n    .version = ver, \\\n    .description = desc, \\\n    .category = cat, \\\n    .priority = pri, \\\n    .resource_requirements = {0.1f, 64, 0}, \\\n    .dependencies_count = 0, \\\n    .init_func = NULL, \\\n    .execute_func = NULL, \\\n    .cleanup_func = NULL, \\\n    .plugin_data = NULL \\\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // CAPABILITY_REGISTRY_H